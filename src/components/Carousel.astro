---
// Componente Principal
import CarouselSlide from "./Carousel/CarouselSlide.astro";
import Photo from "./Carousel/Photo.astro";

---

<carousel-wrapper>
  <div class="carousel">
    <button class="carousel__button carousel__button--prev" id="prevLink" aria-label="Go to previous slide">←</button>

    <ul class="carousel__slides" id="slides">
      <Photo />
    </ul>

    <button class="carousel__button carousel__button--next" id="nextLink" aria-label="Go to next slide">→</button>
  </div>
</carousel-wrapper>

<script>
  class CarouselWrapper extends HTMLElement {
    currentIndex;
    slides: any[] | NodeListOf<Element>;
    prevButton!: Element | null;
    nextButton!: Element | null;
    intervalId: string | number | NodeJS.Timeout | undefined; // ID del intervalo para la rotación automática

    constructor() {
      super();
      this.currentIndex = 0; // Inicializamos el índice en 0
      this.slides = []; // Inicializamos slides como un array
    }

    connectedCallback() {
      // Obtenemos los slides y botones de la interfaz
      this.slides = this.querySelectorAll(".carousel__slides li");
      this.prevButton = this.querySelector("#prevLink");
      this.nextButton = this.querySelector("#nextLink");

      // Aseguramos que prevButton y nextButton no sean null
      if (this.prevButton && this.nextButton) {
        // Asignamos eventos de click a los botones
        this.prevButton.addEventListener("click", () => this._prevSlide());
        this.nextButton.addEventListener("click", () => this._nextSlide());
      }

      // Actualizamos la visibilidad de los slides
      this._updateSlideVisibility();

      // Inicia la rotación automática cada 3 segundos
      this.intervalId = setInterval(() => this._nextSlide(), 3000);
    }

    disconnectedCallback() {
      // Limpia el intervalo al desconectar el componente
      clearInterval(this.intervalId);
    }

    _prevSlide() {
      this.currentIndex = (this.currentIndex - 1 + this.slides.length) % this.slides.length;
      this._updateSlideVisibility();
    }

    _nextSlide() {
      this.currentIndex = (this.currentIndex + 1) % this.slides.length;
      this._updateSlideVisibility();
    }

    _updateSlideVisibility() {
      this.slides.forEach((slide, index) => {
        slide.style.display = index === this.currentIndex ? "block" : "none";
      });
    }
  }

  customElements.define("carousel-wrapper", CarouselWrapper);
</script>

<style>
  /* Estilos del carrusel */
  .carousel {
    display: flex;
    align-items: center; /* Alinea verticalmente */
    width: 100%;
    max-width: 600px;
    margin: 0 auto;
    position: relative; /* Necesario para posicionar las flechas */
  }

  /* Estilos de las slides */
  .carousel__slides {
    list-style: none;
    padding: 0;
    margin: 0;
    width: 100%;
    display: flex;
    overflow: hidden;
  }

  /* Estilos de los botones */
  .carousel__button {
    background-color: rgba(255, 255, 255, 0.8); /* Fondo semi-transparente */
    border: none;
    font-size: 2rem;
    cursor: pointer;
    padding: 0.5rem; /* Espaciado */
    position: absolute; /* Posiciona las flechas */
    top: 50%; /* Centra verticalmente */
    transform: translateY(-50%); /* Ajusta el centrado */
    z-index: 1; /* Asegura que las flechas estén encima */
  }

  /* Posiciona las flechas */
  .carousel__button--prev {
    left: 10px; /* Espaciado del lado izquierdo */
  }

  .carousel__button--next {
    right: 10px; /* Espaciado del lado derecho */
  }

  /* Estilos para los elementos de lista */
  li {
    width: 100%;
    height: auto;
  }
</style>
